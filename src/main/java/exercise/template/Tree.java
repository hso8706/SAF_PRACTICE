package exercise.template;

//트리 구조를 배열로 표현하는 방법
public class Tree { // 제네릭 사용: 노드들의 참조형의 자유도를 높임//nodes 변수 할당
        //private : 노드 접근은 메서드만을 통해서 가능
        //Object[] : 모든 참조형을 받을 수 있도록 설정, 그 중 한가지만
    //SIZE 변수 할당
        //size == tree 전체의 node 개수 + 1
        //+1의 이유는 0번 인덱스는 사용하지 않기 때문이다.
        //private : size는 생성자의 인자로 제공받는다
    //lastIndex 변수 할당
        //nodes를 추가할 때, 인덱스를 카운트하는 용도로 사용

    //생성자
        //size를 제공받아 초기화하고, 이를 바탕으로 node 배열을 초기화한다.

    //메서드1. isFull()
        //lastIndex 변수와 SIZE 변수와 같은지 확인하고 boolean 값을 반환한다.
    //메서드2. add(T e)
        //제네릭 인자를 제공받고, nodes 배열에 추가한다.
        //배열에 값을 추가할 땐 lastIndex 를 늘리면서 추가한다.
        //만약 트리의 노드가 가득 찼을 경우 add가 불가능하게 만든다.
    //메서드3. bfs(); queue 로 구현
}

/*
배열과 트리의 관계
- 인덱스
    - 루트 인덱스 == 1
    - 트리의 좌측에서 우측으로 갈수록 인덱스 상승
    - 가장 우측의 노드 다음 인덱스는 다음 깊이의 가장 좌측의 노드
- 노드 인덱스 성질
    - 노드 번호가 i인 노드의 부모 노드 == i/2
    - 노드 번호가 i인 노드의 자식(왼쪽) 노드 == i*2
    - 노드 번호가 i인 노드의 자식(오른쪽) 노드 == i*2+1
    - 레벨 N의 노드 시작 번호 == 2^N (0<=N)
 */